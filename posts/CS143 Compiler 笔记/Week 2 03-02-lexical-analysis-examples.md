## 一些词法分析的例子

### Fortran

对于 FORTRAN 语言来说，有一个性质/规则：空白是没有影响的。

比如 `VAR1` 与 `VA R1` 是等价的，也就是说，一个 FORTRAN 程序可以不包含任何空白。

看下面这个例子：

```fortran
DO 5 I = 1,25
DO 5 I = 1.25
```

第一行为循环，其中 `DO` 为循环关键字，`5` 为循环的标签，`I` 为循环迭代变量，范围为 `1` 到 `25`。

第二行为变量赋值，其中 `DO 5 I` 整体是一个变量名，也就是 `DO5I = 1.25`。

当我们对这两行分别做词法分析时，从左到右扫描字符串，到 `DO` 后面时，是无法确定这个 `DO` 是循环的关键字还是变量名的一部分，这时候我们需要更多的信息，直到后面的 `,` 与 `.` 的区别才能够得出结果，这被称作是 look ahead。

你也会注意到如果存在过多的 look ahead 会对词法分析系统的实现变得复杂，因此词法系统的设计目标之一就是最小化 lookahead 的数量。

> Fortran 如此设计的原因是早期在穿孔卡片机上编写程序时很容易多出一些空格

对字符串进行分割，从左到右扫描，一次识别一个 token。

### PL/1

对于 PL/1 语言来说，有一个性质：关键字并不是保留的。

也就是说，一个关键字也有可能是用户定义的变量名：

```pl/1
IF ELSE THEN THEN = ELSE; ELSE ELSE = THEN
```

另一个例子：

```pl/1
DECLARE(ARG1, ..., ARGN)
```

难以区分 `DECLARE` 是关键字还是一个数组引用。

需要一路扫描经过整个 N 个 ARG，来得到后面是否为 `=` 来判断，这被称作 unbounded lookahead。

### C++

在 C++ 中的流运算符和嵌套模板：

```c++
vector<vector<int>>
```

```c++
cin >> var;
```

在老的编译器中对于嵌套模板的右侧的两个 `>` 需要写作 `> >`，不过目前大多数编译器都支持识别了。
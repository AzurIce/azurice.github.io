# 进程同步

首先想象这样一个问题：家里冰箱中没有牛奶了，需要去买，A 先打开了冰箱发现没有牛奶并且出发去买，当 A 还在路上的时候 B 又打开了冰箱，然而在互相没有沟通的情况下，就会导致 B 也出发去买，最终导致买了两份牛奶。

**并行** 访问可能会导致 **数据不一致**，而为了维护 **数据一致性**，就需要确保并行进程的 **执行顺序**。

## 竞态

**竞态（Race condition）**指多个进程并行的访问并操作同一片数据，最终数据的结果会取决于最终结束的进程，举个例子：来想象 A 负责对一个变量进行增加，B 负责对一个变量进行减小：

| A                          | B                           |
| -------------------------- | --------------------------- |
| `register1 = cnt`          | `register2 = cnt`           |
| `register1 = register + 1` | `register2 = register2 - 1` |
| `cnt = register1`          | `cnt = register2`           |

假如，`cnt` 最初为 5，理想情况 A 与 B 分别对变量进行一次修改，结果依旧应该是 5。

但是如果执行顺序是这样的：

| A                          | B                           |
| -------------------------- | --------------------------- |
|                            | `register2 = cnt`           |
| `register1 = cnt`          |                             |
|                            | `register2 = register2 - 1` |
| `register1 = register + 1` |                             |
| `cnt = register1`          |                             |
|                            | `cnt = register2`           |

A 计算出 6，B 计算出 4，A 先改 B 再改，那么就会导致最终的结果为 `4`。

为了避免 **竞态**，并行的进程就需要进行 **同步**。

## 原子操作

**原子操作** 指不可再分的操作，他只能完全运行成功或完全不运行成功（你是不是想到了数据库的 Transaction），可以认为只有加载和存储是原子的。

可以发现上面的问题的产生是由于 A 与 B 的执行过程可再分，而这导致二者之间穿插执行的顺序会产生不同的情况，也就导致了不同的结果，很显然如果 A 与 B 都只有一个原子操作，那么结果总会是正确的。

也因此，进程同步要依赖于原子操作来实现。

## 互斥（Mutual Exclusion）与临界区（Critical Section）

**互斥** 表示同一时间只有一个进程执行。

**临界区** 表示同时只能有一个进程执行的代码片段。

## 信号量

信号量持有一个非负整数值，并支持以下两种 **原子** 操作：

- `P()`：等待信号量变为正数，并令其减一
- `V()`：令信号量自增一

有两种信号量：

- Binary：取值为 0 到 1（其实也就是互斥锁）
- Counting：取值不限制（可以用 Binary 信号量实现）

## 一些例子

这前两个问题好像有点烂（）

### 1. 吃水果问题

有一个空盘子，只能放一个水果。A 可以往盘子里放橘子或者苹果，B 只会吃橘子，C 只会吃苹果。

请使用 P, V 操作来实现三个并行的进程：A、B、C。



首先考虑一个简单版本的问题，橘子 = 苹果 = 水果：

那么显而易见可以使用一个 Binary 信号量 `empty` 来标识盘子是否为空（初始为 `1`），使用另一个 Binary 信号量 `fruit` 来标识盘子是否有水果（初始为 `0`），三个进程的操作可以这样表示：

```
A() {
	loop {
		wait(empty);
		signal(fruit);
	}
}
```

```
B、C() {
	loop {
		wait(fruit);
		signal(empty);
	}
}
```

那如果把水果区分为橘子和苹果呢？那就用两个 Binary 信号量 `orange` 和 `apple` 来分别标识盘子中是否有橘子和苹果：

```
A() {
	loop {
		wait(empty);
		fruit = decide_fruit_to_put();
		if fruit is orange {
			signal(orange)
		} else {
			signal(apple);
		}
	}
}
```

```
B() {
	loop {
		wait(orange);
		signal(empty);
	}
}
```

```
C() {
	loop {
		wait(orange);
		signal(empty);
	}
}
```

### 2. 并行程序执行问题

有三个并行的程序 R、M、P，他们共享同一片缓冲区，而这篇缓冲区只能承载一条记录。

R 负责从输入设备读取信息并以此将读到的记录放到缓冲区中。

M 负责处理缓冲区中的记录

P 负责打印缓冲区中的记录

要求 M 要处理 R 得到的数据，P 要打印 M 处理后的数据。



可以看出来他们三个两两互斥，那么也就需要三个 Binary 信号量 `S1`、`S2`、`S3`：

```
R() {
	loop {
		wait(S1)
		signal(S2)
	}
}
```

```
M() {
    loop {
		wait(S2)
		signal(S3)
    }
}
```

```
M() {
    loop {
		wait(S3)
		signal(S1)
    }
}
```

---



